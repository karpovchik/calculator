=================================================================================
/-------------------------------------------------------------------------------/
/                      <<< Программа - Калькулятор >>>                          /
/-------------------------------------------------------------------------------/
/ 1) Чем является результат работы программы?                                   /
/ 2) Какие сущности могут представлять из себя входные данные?                  /
/ 3) Чем представлены промежуточные данные, и как они хранятся в программе?     /
/ 4) Какой алгоритм используется для парсинга входной строкии                   /
/       и подготовки к вычислениям?                                             /
/ 5) Какой алгос испол. для вычисления сформированного выражения?               /
/ 6) Какие ошибки нужно учесть при вводе данныъ, во время вычисления выражения? /
/ 7) Удовлетворяет ли программа (как алгоритм для вычисления арифметического    /
/       выражения определенным критериям).                                      /
=================================================================================

=================================================================================
/-------------------------------------------------------------------------------/
/    Cущность арифмет. выражения представляется в виде объекта класса Token     /
/-------------------------------------------------------------------------------/
/ Класс Token. Его структура:                                                   /
/ 1) Данные:                                                                    /
/   1.1) kind - оператор, скобка или 1 символ названия функции (s - sin);       /
/   1.2) value для хранения самой сущности, тип данных double;                  /
/   1.3) type для хранения типа операции (унарная или бинарная);                /
/   1.4) func - строка для хранения названия функции;                           /
/   1.5) priority для хранения приоритета оператора;                            /
/ 2) Три конструктора:                                                          /
/   2.1) Для инициализации объекта (по умолчанию);                              /
/   2.2) Для инициализации объекта;                                             /
/ 3) get-функции для получения данных;                                          /
/ 4) set-функции для присвоения нового значения данным.                         /
=================================================================================

=================================================================================
/-------------------------------------------------------------------------------/
/   После определения типа сущности и формирования на ее основе лексемы,        /
/      формируется узел - объект типа struct, единица хранения информации       /
/-------------------------------------------------------------------------------/
/ Структура узла:                                                               /
/ 1) Данные:                                                                    /
/   1.1) token - смысловая нагрузка;                                            /
/   1.2) prev, next - указатели для связи токенов в *ЛСС;                       /
=================================================================================
*ЛСС - Линейный Связный Список.

=================================================================================
/-------------------------------------------------------------------------------/
/   Узлы хранятся В *АТД стэк и очередь, об использовании двух АТД              /
/       будет расписано в разделе, посвященном алгоритмам                       /
/-------------------------------------------------------------------------------/
/ Структура хранилища:                                                          /
/ 1) Данные:                                                                    /
/   1.1) Узел со смысловой и служебной информацией Node;                        /
/   1.2) Указатели front, end - для работы с узлами;                            /
/   1.3) Количество элементов в хранилище size;                                 /
/ 2) Методы класса:                                                             /
/   2.1) Добавление элемента:                                                   /
/       - push_front();                                                         /
/       - push_back();                                                          /
/   2.2) Удаление элемента (с возвратом элемента):                              /
/       - pop_front();                                                          /
/   2.3) Получение первого элемента:                                            /
/       - get_front();                                                          /
/   2.4) Получение размера хранилища:                                           /
/       - get_size();                                                           /
/   2.5) Конструторы класса:                                                    /
/       - Конструктор по умолчанию;                                             /
/       - Конструктор с параметрами;                                            /
/   2.6) Инкремент и декремент size:                                            /
/       - inc_size();                                                           /
/       - dec_size();                                                           /
=================================================================================
*АТД - Абстрактный Тип Данных.

=================================================================================
/-------------------------------------------------------------------------------/
/               Функция для парсинга входной строки - get_symbl()               /
/-------------------------------------------------------------------------------/
/ 1) На вход подается символ;                                                   /
/ 2) Происходит распределение по функциям, для формирования соответствующей     /
/       лексемы и добавления её в стэк или в очередь;                           /
/-------------------------------------------------------------------------------/
=================================================================================

=================================================================================
/-------------------------------------------------------------------------------/
/       Функция для определения приоритета оператора - op_priority()            /
/-------------------------------------------------------------------------------/
/ 1) На основании значения в поле priority лексемы принимается решение,         /
/       к какому приоритету отнести текущий оператор;                           /
/ 2) Учитывается ситуация, когда стэк пуст;                                     /
/-------------------------------------------------------------------------------/
=================================================================================

Для реализации унарного минуса имеет смысл во время обработки выражения принять его за '~'.
